import fs from 'fs';
import path from 'path';
import { Transcript, TranscriptSegment } from '../types';
import { Step2Output, Step3Output, Step5Output } from '../types/workflow';

export interface SaveTranscriptOptions {
  videoName: string;
  outputDir: string;
  includeEnhanced?: boolean;
  step3Output?: Step3Output;
}

// Format timestamp for display
function formatTimestamp(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// Save transcript as markdown
export async function saveTranscriptAsMarkdown(
  step2Output: Step2Output,
  options: SaveTranscriptOptions
): Promise<Step5Output> {
  const { videoName, outputDir, includeEnhanced, step3Output } = options;

  // Ensure output directory exists
  await fs.promises.mkdir(outputDir, { recursive: true });

  let markdown = `# ${videoName}\n\n`;
  markdown += `**Transcribed:** ${new Date(step2Output.transcribedAt).toLocaleDateString()}\n`;
  markdown += `**Provider:** ${step2Output.provider}\n`;
  markdown += `**Segments:** ${step2Output.segments.length}\n\n`;
  markdown += `---\n\n`;

  // Include enhanced transcript if available
  if (includeEnhanced && step3Output) {
    markdown += `## Enhanced Transcript\n\n`;
    markdown += `${step3Output.enhancedTranscript}\n\n`;

    // Include sections if available
    if (step3Output.sections && step3Output.sections.length > 0) {
      markdown += `## Sections\n\n`;
      step3Output.sections.forEach((section, i) => {
        markdown += `### ${i + 1}. ${section.title}\n`;
        markdown += `*${formatTimestamp(section.startTime)} - ${formatTimestamp(section.endTime)}*\n\n`;
      });
    }

    // Include key moments
    if (step3Output.keyFrames && step3Output.keyFrames.length > 0) {
      markdown += `## Key Moments\n\n`;
      step3Output.keyFrames.forEach((kf) => {
        markdown += `- **${formatTimestamp(kf.timestamp)}** - ${kf.reason}\n`;
      });
      markdown += '\n';
    }

    markdown += `---\n\n`;
  }

  // Raw transcript with timestamps
  markdown += `## Raw Transcript\n\n`;

  step2Output.segments.forEach((segment) => {
    const text = segment.correctedText || segment.text;
    markdown += `**[${formatTimestamp(segment.start)}]** ${text}\n\n`;
  });

  markdown += `---\n\n`;
  markdown += `*Generated by Video KeyFrame Capturer*\n`;

  // Save the markdown file
  const markdownPath = path.join(outputDir, 'transcript.md');
  await fs.promises.writeFile(markdownPath, markdown, 'utf-8');

  console.log(`Transcript saved to ${markdownPath}`);

  return {
    markdownPath,
    markdownUrl: `/output/${path.basename(outputDir)}/transcript.md`,
    savedAt: new Date().toISOString(),
  };
}

// Generate a simple markdown summary
export function generateMarkdownSummary(
  videoName: string,
  segments: TranscriptSegment[],
  keyFrames?: { timestamp: number; reason: string }[]
): string {
  let markdown = `# ${videoName} - Summary\n\n`;

  // Calculate duration
  if (segments.length > 0) {
    const lastSegment = segments[segments.length - 1];
    const duration = lastSegment.end;
    const mins = Math.floor(duration / 60);
    const secs = Math.floor(duration % 60);
    markdown += `**Duration:** ${mins}m ${secs}s\n`;
    markdown += `**Segments:** ${segments.length}\n\n`;
  }

  // Key moments
  if (keyFrames && keyFrames.length > 0) {
    markdown += `## Key Moments\n\n`;
    keyFrames.forEach((kf) => {
      markdown += `- **${formatTimestamp(kf.timestamp)}** - ${kf.reason}\n`;
    });
    markdown += '\n';
  }

  // First few segments as preview
  markdown += `## Preview\n\n`;
  const previewSegments = segments.slice(0, 5);
  previewSegments.forEach((segment) => {
    const text = segment.correctedText || segment.text;
    markdown += `> ${text}\n\n`;
  });

  if (segments.length > 5) {
    markdown += `*... and ${segments.length - 5} more segments*\n`;
  }

  return markdown;
}

// Convert segments to plain text
export function segmentsToPlainText(segments: TranscriptSegment[]): string {
  return segments
    .map((seg) => seg.correctedText || seg.text)
    .join(' ')
    .replace(/\s+/g, ' ')
    .trim();
}

// Export transcript in different formats
export async function exportTranscript(
  segments: TranscriptSegment[],
  outputPath: string,
  format: 'txt' | 'srt' | 'vtt' = 'txt'
): Promise<void> {
  let content = '';

  switch (format) {
    case 'txt':
      content = segmentsToPlainText(segments);
      break;

    case 'srt':
      segments.forEach((seg, i) => {
        content += `${i + 1}\n`;
        content += `${formatSrtTimestamp(seg.start)} --> ${formatSrtTimestamp(seg.end)}\n`;
        content += `${seg.correctedText || seg.text}\n\n`;
      });
      break;

    case 'vtt':
      content = 'WEBVTT\n\n';
      segments.forEach((seg) => {
        content += `${formatVttTimestamp(seg.start)} --> ${formatVttTimestamp(seg.end)}\n`;
        content += `${seg.correctedText || seg.text}\n\n`;
      });
      break;
  }

  await fs.promises.writeFile(outputPath, content, 'utf-8');
}

// Format timestamp for SRT format (HH:MM:SS,mmm)
function formatSrtTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
}

// Format timestamp for VTT format (HH:MM:SS.mmm)
function formatVttTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
}
